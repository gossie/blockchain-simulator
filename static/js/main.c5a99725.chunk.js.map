{"version":3,"sources":["model/miner-event.ts","view/Miner.tsx","view/OpenTransaction.tsx","model/transaction-model.ts","view/TransactionForm.tsx","view/Block.tsx","view/Blockchain.tsx","model/block-model.ts","model/blockchain-model.ts","model/miner-model.ts","view/App.tsx","serviceWorker.ts","index.tsx"],"names":["EventType","MinerEvent","_eventType","_payload","this","Miner","props","useState","message","setMessage","proofOfWork","setProofOfWork","mining","setMining","miner","minedBlocks","setMinedBlocks","rejectedBlocks","setRejectedBlocks","cssClass","setCssClass","useEffect","subscription","observeProofOfWorkSearch","subscribe","current","eventType","CheckingBlock","payload","BlockCreated","old","BlockRejected","unsubscribe","className","index","onClick","startMining","pauseMining","OpenTransaction","transaction","amount","from","to","TransactionModel","_from","_to","_amount","participants","TransactionForm","setFrom","setTo","setAmount","blockchain","openTransactions","setOpenTransactions","observeNewBlock","transactions","map","key","i","Math","round","random","newTransaction","addOpenTransaction","t","data-testid","type","value","onChange","event","parseInt","target","length","Block","block","s","hash","previousHash","Blockchain","mapBlocks","b","reverse","blocks","setBlocks","BlockModel","_transactions","_previousHash","_proofOfWork","_hash","transactionsAsString","join","createHash","update","digest","BlockchainModel","_blockSubject","_blocks","_openTransactions","genesis","push","BehaviorSubject","asObservable","newBlock","splice","MAX_BLOCK_SIZE","top","pipe","EveryReduceOperator","b1","b2","checkBlocks","window","setTimeout","next","falseBlock","pop","unshift","Error","block1","block2","startsWith","PROOF_OF_WORK_CONSTRAINT","reducer","_lastBlock","undefined","reducerResult","operatorResult","done","TerminalOperator","MinerModel","_blockchain","_proofOfWorkSubject","Subject","_miningSubscription","_blockSubscription","_top","_miningIncrementor","_delay","_minedBlocks","_rejectedBlocks","console","debug","interval","MINING_TIMEOUT","delayWhen","timer","mine","addBlock","e","App","miner1","miner2","miner3","tearDown","href","rel","Boolean","location","hostname","match","ReactDOM","render","document","getElementById","navigator","serviceWorker","ready","then","registration","unregister"],"mappings":"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","file":"static/js/main.c5a99725.chunk.js","sourcesContent":["export enum EventType {\n    CheckingBlock,\n    BlockCreated,\n    BlockRejected\n}\n\nexport class MinerEvent {\n\n    constructor(private _eventType: EventType,\n                private _payload?: any) {}\n\n    public get eventType(): EventType {\n        return this._eventType;\n    }\n\n    public get payload(): any {\n        return this._payload;\n    }\n\n}","import React, { useEffect, useState } from 'react';\nimport { Subscription } from 'rxjs';\nimport MinerModel from '../model/miner-model';\nimport './Miner.css';\nimport { MinerEvent, EventType } from '../model/miner-event';\n\ninterface MinerProps {\n    index: number;\n    miner: MinerModel;\n}\n\nconst Miner: React.FC<MinerProps> = (props: MinerProps) => {\n    const [message, setMessage] = useState('I am waiting!');\n    const [proofOfWork, setProofOfWork] = useState('');\n    const [mining, setMining] = useState(false);\n    const [minedBlocks, setMinedBlocks] = useState(props.miner.minedBlocks);\n    const [rejectedBlocks, setRejectedBlocks] = useState(props.miner.rejectedBlocks);\n    const [cssClass, setCssClass] = useState('has-text-black');\n    useEffect(() => {\n        const subscription: Subscription = props.miner.observeProofOfWorkSearch().subscribe((current: MinerEvent) => {\n            switch (current.eventType) {\n                case EventType.CheckingBlock:\n                    setProofOfWork(`Currently checking ${current.payload}`);\n                    setCssClass('has-text-black');\n                    break;\n                case EventType.BlockCreated:\n                    setProofOfWork(`Wohoo! It worked. I am creating a new block.`);\n                    setCssClass('has-text-success');\n                    setMinedBlocks((old: number) => old + 1);\n                    break;\n                case EventType.BlockRejected:\n                    setProofOfWork(`Block was not added. Proof of work does not fullfill constraint.`);\n                    setCssClass('has-text-danger');\n                    setRejectedBlocks((old: number) => old + 1);\n                    break;\n            }\n        });\n        return () => subscription.unsubscribe();\n    });\n\n    const startMining = () => {\n        setMining(true);\n        setMessage('I am mining!');\n        props.miner.startMining();\n    };\n\n    const pauseMining = () => {\n        setMining(false);\n        setMessage('I am waiting!');\n        props.miner.pauseMining();\n    };\n\n    return (\n        <div className=\"miner\">\n            <h2 className=\"title\">Miner {props.index}</h2>\n            <div>\n                {message}\n            </div>\n            <div className={cssClass}>\n                {proofOfWork}\n            </div>\n            <div className=\"mined\">\n                {minedBlocks} blocks were successfully mined.\n            </div>\n            <div className=\"rejected\">\n                {rejectedBlocks} blocks were rejected.\n            </div>\n            <div>\n                <button className={\"button is-link \" + (mining ? 'is-loading' : '')} onClick={startMining}>Start</button>\n                <button className=\"button is-link\" onClick={pauseMining}>Pause</button>\n            </div>\n        </div>\n    );\n};\n\nexport default Miner;\n","import React from 'react';\nimport TransactionModel from '../model/transaction-model';\n\ninterface TransactionProps {\n    transaction: TransactionModel;\n}\n\nconst OpenTransaction: React.FC<TransactionProps> = (props: TransactionProps) => {\n    return(\n        <div>\n            Transfer {props.transaction.amount} from {props.transaction.from} to {props.transaction.to}.\n        </div>\n    );\n}\n\nexport default OpenTransaction;\n","export default class TransactionModel {\n\n    public get from(): string {\n        return this._from;\n    }\n\n    public get to(): string {\n        return this._to;\n    }\n\n    public get amount(): number {\n        return this._amount;\n    }\n\n    constructor(private _from: string,\n                private _to: string,\n                private _amount: number) {}\n\n}\n","import React, { useState, ChangeEvent, useEffect } from 'react';\nimport OpenTransaction from './OpenTransaction';\nimport BlockchainModel from '../model/blockchain-model';\nimport TransactionModel from '../model/transaction-model';\nimport { Subscription } from 'rxjs';\n\nimport './TransactionForm.css'\n\nconst participants = ['A', 'B', 'C', 'D', 'E', 'F', 'G', 'H', 'I', 'J', 'K', 'L', 'M', 'N', 'O', 'P', 'Q', 'R', 'S', 'T', 'U', 'V', 'W', 'X', 'Y', 'Z'];\n\ninterface TransactionFormProps {\n    blockchain: BlockchainModel\n}\n\nconst TransactionForm: React.FC<TransactionFormProps> = (props: TransactionFormProps) => {\n    const [from, setFrom] = useState('');\n    const [to, setTo] = useState('');\n    const [amount, setAmount] = useState(1);\n    const [openTransactions, setOpenTransactions] = useState([...props.blockchain.openTransactions]);\n\n    const randomTransactions = () => {\n        for (let i=0; i<15; i++) {\n            const from = participants[Math.round(Math.random() * 25)];\n            const to = participants[Math.round(Math.random() * 25)];\n            const newTransaction = new TransactionModel(from, to, Math.round(Math.random() * 12) + 1);\n            props.blockchain.addOpenTransaction(newTransaction);\n            setOpenTransactions(t => [...t, newTransaction]);\n        }\n    }\n\n    const onAmountChange = (event: ChangeEvent<HTMLInputElement>) => {\n        const value: number = parseInt(event.target.value);\n        if (value) {\n            setAmount(value);\n        } else {\n            setAmount(1);\n        }\n    }\n\n    const addTransaction = () => {\n        const newTransaction = new TransactionModel(from, to, amount);\n        props.blockchain.addOpenTransaction(newTransaction);\n        setOpenTransactions(t => [...t, newTransaction]);\n    };\n\n    useEffect(() => {\n        const subscription: Subscription = props.blockchain.observeNewBlock().subscribe(() => setOpenTransactions([...props.blockchain.openTransactions]));\n        return () => subscription.unsubscribe();\n    }, [props.blockchain]);\n\n    const transactions = openTransactions\n        .map((transaction: TransactionModel, index: number) => <OpenTransaction key={index} transaction={transaction} />);\n\n    return (\n        <div>\n            <div>\n                <h2 className=\"title\">Open transactions</h2>\n                <div className=\"row\">\n                    <button className=\"button is-link\" onClick={randomTransactions}>Create 15 random transactions</button>\n                </div>\n                <div className=\"transaction-form row\">\n                    Transfer <input data-testid=\"amount\" className=\"input\" type=\"text\" value={amount} onChange={onAmountChange} /> \n                    from <input data-testid=\"from\" className=\"input\" type=\"text\" value={from} onChange={event => setFrom(event.target.value)} /> \n                    to <input data-testid=\"to\" className=\"input\" type=\"text\" value={to} onChange={event => setTo(event.target.value)} />\n                    <button data-testid=\"add\" className=\"button is-link\" onClick={addTransaction}>Add</button>\n                </div>\n            </div>\n            <div className=\"row\">\n                Currently there are {transactions.length} open transactions.\n            </div>\n            <div className=\"row\">\n                {transactions}\n            </div>\n        </div>\n    );\n};\n\nexport default TransactionForm","import React from 'react';\nimport './Block.css';\nimport BlockModel from '../model/block-model';\nimport TransactionModel from '../model/transaction-model';\n\n\ninterface BlockProps {\n    block: BlockModel;\n}\n\nconst Block: React.FC<BlockProps> = (props: BlockProps) => {\n    const transactions = props.block.transactions\n        .map((transaction: TransactionModel) => `Transfered ${transaction.amount} from ${transaction.from} to ${transaction.to}`)\n        .map((s: string, index: number) => <li key={index}>{s}</li>);\n    return (\n        <div className=\"block box\">\n            { transactions.length > 0 && <div><b>Transactions:</b> <ul>{transactions}</ul></div> }\n            <b>Proof of work:</b> {props.block.proofOfWork}<br />\n            <b>Hash:</b> {props.block.hash}<br />\n            { props.block.previousHash.length > 0 && <div><b>Previous hash:</b> {props.block.previousHash}</div> }\n        </div>\n    );\n};\n\nexport default Block;","import React, { useEffect, useState } from 'react';\nimport Block from './Block';\nimport BlockchainModel from '../model/blockchain-model';\nimport BlockModel from '../model/block-model';\nimport { Subscription } from 'rxjs';\nimport './Blockchain.css';\n\ninterface BlockchainProps {\n    blockchain: BlockchainModel;\n}\n\nconst Blockchain: React.FC<BlockchainProps> = (props: BlockchainProps) => {\n\n    const mapBlocks = (b: Array<BlockModel>) => b.map((block: BlockModel, index: number) => <Block key={index} block={block} />).reverse();\n\n    const [blocks, setBlocks] = useState(mapBlocks(props.blockchain.blocks));\n\n    useEffect(() => {\n        const subscription: Subscription = props.blockchain.observeNewBlock().subscribe(() => setBlocks(mapBlocks(props.blockchain.blocks)));\n        return () => subscription.unsubscribe();\n    }, [props.blockchain]);\n\n    \n    return (\n        <div className=\"blockchain\">\n            <h2 className=\"title\">Blockchain</h2>\n            {blocks}\n        </div>\n    );\n};\n\nexport default Blockchain;\n","import TransactionModel from \"./transaction-model\";\nimport { createHash } from \"crypto\";\n\nexport default class BlockModel {\n\n    private _hash: string;\n\n    constructor(private _transactions: Array<TransactionModel>,\n                private _previousHash: string,\n                private _proofOfWork: number) {\n\n        const transactionsAsString: string = _transactions\n            .map((transaction: TransactionModel) => `${transaction.from}${transaction.to}${transaction.amount}`)\n            .join();\n\n        this._hash = createHash('sha256')\n            .update(transactionsAsString)\n            .update(`${_previousHash}`)\n            .update(`${_proofOfWork}`)\n            .digest('hex');\n    }\n\n\n    \n    public get transactions(): Array<TransactionModel> {\n        return this._transactions;\n    }\n\n    public get previousHash(): string {\n        return this._previousHash;\n    }\n\n    public get hash(): string {\n        return this._hash;\n    }\n\n    public get proofOfWork(): number {\n        return this._proofOfWork;\n    }\n}\n","import { Subject, BehaviorSubject, Observable } from 'rxjs';\nimport '@gossie/array-pipe';\nimport BlockModel from './block-model';\nimport TransactionModel from './transaction-model';\nimport { Operator, TerminalOperator, OperatorResult } from '@gossie/array-pipe/operators';\nimport { createHash } from 'crypto';\n\nexport default class BlockchainModel {\n\n    public static readonly PROOF_OF_WORK_CONSTRAINT = '00';\n    private static readonly MAX_BLOCK_SIZE = 5;\n\n    private _blockSubject: Subject<BlockModel>;\n    private _blocks: Array<BlockModel> = [];\n    private _openTransactions: Array<TransactionModel> = [];\n\n    constructor() {\n        const genesis = new BlockModel([], '', 123);\n        this._blocks.push(genesis);\n        this._blockSubject = new BehaviorSubject(genesis);\n    }\n\n    public observeNewBlock(): Observable<BlockModel> {\n        return this._blockSubject.asObservable();\n    }\n\n    public get top(): BlockModel {\n        return this._blocks[this._blocks.length - 1];\n    }\n\n    public get blocks(): Array<BlockModel> {\n        return this._blocks;\n    }\n\n    public get openTransactions(): Array<TransactionModel> {\n        return this._openTransactions;\n    }\n\n    public addOpenTransaction(transaction: TransactionModel): void {\n        this._openTransactions.push(transaction);\n    }\n\n    public addBlock(proofOfWork: number): void {\n        const newBlock = new BlockModel(this._openTransactions.splice(0, BlockchainModel.MAX_BLOCK_SIZE), this.top.hash, proofOfWork);\n        this._blocks.push(newBlock);\n\n        const blockchainConsistent: boolean = this._blocks.pipe(\n            everyReduce((b1: BlockModel, b2: BlockModel) => this.checkBlocks(b1, b2))\n        )\n\n        if (blockchainConsistent) {\n            window.setTimeout(() => this._blockSubject.next(newBlock), 5000);\n        } else {\n            const falseBlock = this._blocks.pop();\n            if (falseBlock) {\n                switch (falseBlock.transactions.length) {\n                    case 1: this._openTransactions.unshift(falseBlock.transactions[0]); break;\n                    case 2: this._openTransactions.unshift(falseBlock.transactions[0], falseBlock.transactions[1]); break;\n                    case 3: this._openTransactions.unshift(falseBlock.transactions[0], falseBlock.transactions[1], falseBlock.transactions[2]); break;\n                    case 4: this._openTransactions.unshift(falseBlock.transactions[0], falseBlock.transactions[1], falseBlock.transactions[2], falseBlock.transactions[3]); break; \n                    case 5: this._openTransactions.unshift(falseBlock.transactions[0], falseBlock.transactions[1], falseBlock.transactions[2], falseBlock.transactions[3], falseBlock.transactions[4]); break;\n                    default: break;\n                }\n                throw new Error(`Block was not added. Proof of work ${proofOfWork} does not fullfill constraint.`);\n            }\n        }\n    }\n\n    private checkBlocks(block1: BlockModel, block2: BlockModel): boolean {\n        return createHash('sha256')\n            .update(`${block1.proofOfWork}${block2.proofOfWork}${block1.hash}`)\n            .digest('hex')\n            .startsWith(BlockchainModel.PROOF_OF_WORK_CONSTRAINT);\n    }\n}\n\ninterface BiFunction<A, B, C> {\n    (a: A, b: B): C;\n};\n\nclass EveryReduceOperator extends TerminalOperator<BlockModel, boolean> {\n\n    private _lastBlock: BlockModel | undefined = undefined;\n\n    constructor(private reducer: BiFunction<BlockModel, BlockModel, boolean>) {\n        super();\n    }\n\n    public getFallbackValue(): boolean {\n        return true;\n    }\n\n    public perform(from: BlockModel): OperatorResult<boolean> {\n        if (this._lastBlock) {\n            const reducerResult: boolean = this.reducer(this._lastBlock, from);\n            const operatorResult: OperatorResult<boolean> =  {\n                value: reducerResult,\n                done: !reducerResult\n            };\n            this._lastBlock = from;\n            return operatorResult;\n        } else {\n            this._lastBlock = from;\n            return {\n                value: false,\n                done: false\n            };\n        }\n    }\n\n}\n\nfunction everyReduce(reducer: BiFunction<BlockModel, BlockModel, boolean>): Operator<BlockModel, boolean> {\n    return new EveryReduceOperator(reducer);\n}\n","import BlockchainModel from \"./blockchain-model\";\nimport { createHash } from \"crypto\";\nimport BlockModel from './block-model';\nimport { Subscription, interval, timer, Subject, Observable } from \"rxjs\";\nimport { delayWhen } from 'rxjs/operators';\nimport { MinerEvent, EventType } from \"./miner-event\";\n\nexport default class MinerModel {\n\n    private static readonly MINING_TIMEOUT = 50;\n\n    private _proofOfWorkSubject: Subject<MinerEvent> = new Subject();\n    private _miningSubscription: Subscription | undefined = undefined;\n    private _blockSubscription: Subscription;\n    private _top: BlockModel;\n    private _proofOfWork = 0;\n    private _miningIncrementor = 1;\n    private _delay = false;\n    private _minedBlocks = 0;\n    private _rejectedBlocks = 0;\n\n    constructor(private  _blockchain: BlockchainModel) {\n        console.debug('Miner is created');\n        this._top = _blockchain.top;\n        this._blockSubscription = _blockchain.observeNewBlock()\n            .subscribe((block: BlockModel) => {\n                this._top = block;\n            });\n    }\n\n    public get minedBlocks(): number {\n        return this._minedBlocks;\n    }\n\n    public get rejectedBlocks(): number {\n        return this._rejectedBlocks;\n    }\n\n    public observeProofOfWorkSearch(): Observable<MinerEvent> {\n        return this._proofOfWorkSubject.asObservable();\n    }\n\n    public startMining(): void {\n        this._miningSubscription = interval(MinerModel.MINING_TIMEOUT)\n            .pipe(\n                delayWhen(() => this._delay ? timer(3000) : timer(0))\n            )\n            .subscribe(() => this.mine());\n    }\n\n    public pauseMining(): void {\n        this._miningSubscription?.unsubscribe();\n    }\n\n    public tearDown(): void {\n        if (this._miningSubscription) {\n            this._miningSubscription.unsubscribe();\n        }\n        this._blockSubscription.unsubscribe();\n    }\n\n    private mine(): void {\n        this._delay = false;\n        this._proofOfWorkSubject.next(new MinerEvent(EventType.CheckingBlock, this._proofOfWork));\n\n        const aHash: string = createHash('sha256')\n            .update(`${this._top.proofOfWork}${this._proofOfWork}${this._top.hash}`)\n            .digest('hex');\n        if (aHash.startsWith(BlockchainModel.PROOF_OF_WORK_CONSTRAINT)) {\n            try {\n                this._blockchain.addBlock(this._proofOfWork);\n                this._proofOfWorkSubject.next(new MinerEvent(EventType.BlockCreated));\n                this._proofOfWork = 0;\n                this._miningIncrementor *= -1;\n                ++this._minedBlocks;\n            } catch (e) {\n                this._proofOfWorkSubject.next(new MinerEvent(EventType.BlockRejected));\n                this._proofOfWork += this._miningIncrementor;\n                ++this._rejectedBlocks;\n            }\n            this._delay = true;\n        } else {\n            this._proofOfWork += this._miningIncrementor;\n        }\n    }\n\n}","import React, { useEffect } from 'react';\nimport './App.css';\nimport Miner from './Miner';\nimport TransactionForm from './TransactionForm';\nimport Blockchain from './Blockchain';\nimport BlockchainModel from '../model/blockchain-model';\nimport MinerModel from '../model/miner-model';\n\nconst App: React.FC = () => {\n    \n    const blockchain: BlockchainModel = new BlockchainModel();\n    const miner1: MinerModel = new MinerModel(blockchain);\n    const miner2: MinerModel = new MinerModel(blockchain);\n    const miner3: MinerModel = new MinerModel(blockchain);\n\n    useEffect(() => {\n        return () => {\n            miner1.tearDown();\n            miner2.tearDown();\n            miner3.tearDown();\n        };\n    });\n    \n    return (\n        <div className=\"tile is-ancestor\">\n            <div className=\"tile is-vertical\">\n                <div className=\"tile is-parent\">\n                    <div className=\"tile is-child box\">\n                        <p>\n                            After reading Daniel van Flymen's article on <a href=\"https://hackernoon.com/learn-blockchains-by-building-one-117428612f46\" target=\"_blank\" rel=\"noopener noreferrer\">learning blockchains by building one</a>, I wrote this blockchain simulator. It currently consists of three miners that try to find blocks. Each miner is trying to find a prrof of work that fulfills this constraint:<br />\n                            <code>hash(proofOfWorkToCheck + lastProofOfWork + lastHash).startsWith('00')</code>\n                        </p>\n                        <p>\n                            Once a miner found a valid proof of work a block is created. It takes five seconds until the new block is replicated to all miners. This way sometimes blocks are mined, that are rejected by the blockchain.\n                        </p>\n                    </div>\n                </div>\n                <div className=\"tile\">\n                    <div className=\"tile is-parent\">\n                        <div className=\"tile is-child box\">\n                            <TransactionForm blockchain={blockchain} />\n                        </div>\n                    </div>\n                    <div className=\"tile is-parent is-vertical\">\n                        <div className=\"tile is-parent box\">\n                            <div className=\"tile is-child\">\n                                <Miner miner={miner1} index={1} />\n                            </div>\n                            <div className=\"tile is-child\">\n                                <Miner miner={miner2} index={2} />\n                            </div>\n                            <div className=\"tile is-child\">\n                                <Miner miner={miner3} index={3} />\n                            </div>\n                        </div>\n                        <div className=\"tile is-child box\">\n                            <Blockchain blockchain={blockchain} />\n                        </div>\n                    </div>\n                </div>\n            </div>\n        </div>\n    );\n}\n\nexport default App;\n","// This optional code is used to register a service worker.\n// register() is not called by default.\n\n// This lets the app load faster on subsequent visits in production, and gives\n// it offline capabilities. However, it also means that developers (and users)\n// will only see deployed updates on subsequent visits to a page, after all the\n// existing tabs open on the page have been closed, since previously cached\n// resources are updated in the background.\n\n// To learn more about the benefits of this model and instructions on how to\n// opt-in, read https://bit.ly/CRA-PWA\n\nconst isLocalhost = Boolean(\n  window.location.hostname === 'localhost' ||\n    // [::1] is the IPv6 localhost address.\n    window.location.hostname === '[::1]' ||\n    // 127.0.0.0/8 are considered localhost for IPv4.\n    window.location.hostname.match(\n      /^127(?:\\.(?:25[0-5]|2[0-4][0-9]|[01]?[0-9][0-9]?)){3}$/\n    )\n);\n\ntype Config = {\n  onSuccess?: (registration: ServiceWorkerRegistration) => void;\n  onUpdate?: (registration: ServiceWorkerRegistration) => void;\n};\n\nexport function register(config?: Config) {\n  if (process.env.NODE_ENV === 'production' && 'serviceWorker' in navigator) {\n    // The URL constructor is available in all browsers that support SW.\n    const publicUrl = new URL(\n      process.env.PUBLIC_URL,\n      window.location.href\n    );\n    if (publicUrl.origin !== window.location.origin) {\n      // Our service worker won't work if PUBLIC_URL is on a different origin\n      // from what our page is served on. This might happen if a CDN is used to\n      // serve assets; see https://github.com/facebook/create-react-app/issues/2374\n      return;\n    }\n\n    window.addEventListener('load', () => {\n      const swUrl = `${process.env.PUBLIC_URL}/service-worker.js`;\n\n      if (isLocalhost) {\n        // This is running on localhost. Let's check if a service worker still exists or not.\n        checkValidServiceWorker(swUrl, config);\n\n        // Add some additional logging to localhost, pointing developers to the\n        // service worker/PWA documentation.\n        navigator.serviceWorker.ready.then(() => {\n          console.log(\n            'This web app is being served cache-first by a service ' +\n              'worker. To learn more, visit https://bit.ly/CRA-PWA'\n          );\n        });\n      } else {\n        // Is not localhost. Just register service worker\n        registerValidSW(swUrl, config);\n      }\n    });\n  }\n}\n\nfunction registerValidSW(swUrl: string, config?: Config) {\n  navigator.serviceWorker\n    .register(swUrl)\n    .then(registration => {\n      registration.onupdatefound = () => {\n        const installingWorker = registration.installing;\n        if (installingWorker == null) {\n          return;\n        }\n        installingWorker.onstatechange = () => {\n          if (installingWorker.state === 'installed') {\n            if (navigator.serviceWorker.controller) {\n              // At this point, the updated precached content has been fetched,\n              // but the previous service worker will still serve the older\n              // content until all client tabs are closed.\n              console.log(\n                'New content is available and will be used when all ' +\n                  'tabs for this page are closed. See https://bit.ly/CRA-PWA.'\n              );\n\n              // Execute callback\n              if (config && config.onUpdate) {\n                config.onUpdate(registration);\n              }\n            } else {\n              // At this point, everything has been precached.\n              // It's the perfect time to display a\n              // \"Content is cached for offline use.\" message.\n              console.log('Content is cached for offline use.');\n\n              // Execute callback\n              if (config && config.onSuccess) {\n                config.onSuccess(registration);\n              }\n            }\n          }\n        };\n      };\n    })\n    .catch(error => {\n      console.error('Error during service worker registration:', error);\n    });\n}\n\nfunction checkValidServiceWorker(swUrl: string, config?: Config) {\n  // Check if the service worker can be found. If it can't reload the page.\n  fetch(swUrl, {\n    headers: { 'Service-Worker': 'script' }\n  })\n    .then(response => {\n      // Ensure service worker exists, and that we really are getting a JS file.\n      const contentType = response.headers.get('content-type');\n      if (\n        response.status === 404 ||\n        (contentType != null && contentType.indexOf('javascript') === -1)\n      ) {\n        // No service worker found. Probably a different app. Reload the page.\n        navigator.serviceWorker.ready.then(registration => {\n          registration.unregister().then(() => {\n            window.location.reload();\n          });\n        });\n      } else {\n        // Service worker found. Proceed as normal.\n        registerValidSW(swUrl, config);\n      }\n    })\n    .catch(() => {\n      console.log(\n        'No internet connection found. App is running in offline mode.'\n      );\n    });\n}\n\nexport function unregister() {\n  if ('serviceWorker' in navigator) {\n    navigator.serviceWorker.ready.then(registration => {\n      registration.unregister();\n    });\n  }\n}\n","import React from 'react';\nimport ReactDOM from 'react-dom';\nimport './index.css';\nimport App from './view/App';\nimport * as serviceWorker from './serviceWorker';\n\nReactDOM.render(<App />, document.getElementById('root'));\n\n// If you want your app to work offline and load faster, you can change\n// unregister() to register() below. Note this comes with some pitfalls.\n// Learn more about service workers: https://bit.ly/CRA-PWA\nserviceWorker.unregister();\n"],"sourceRoot":""}