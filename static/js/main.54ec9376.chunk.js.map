{"version":3,"sources":["Miner.tsx","OpenTransaction.tsx","model/transaction-model.ts","TransactionForm.tsx","Block.tsx","Blockchain.tsx","model/block-model.ts","model/blockchain-model.ts","model/miner-model.ts","App.tsx","serviceWorker.ts","index.tsx"],"names":["Miner","props","useState","proofOfWork","setProofOfWork","useEffect","subscription","miner","observeProofOfWorkSearch","subscribe","current","unsubscribe","OpenTransaction","transaction","amount","from","to","TransactionModel","_from","_to","_amount","this","TransactionForm","setFrom","setTo","setAmount","openTransactions","setOpenTransactions","blockchain","observeNewBlock","transactions","map","index","key","data-testid","className","type","value","onChange","event","parseInt","target","onClick","newTransaction","addOpenTransaction","t","Block","block","join","previousHash","hash","Blockchain","blocks","reverse","setBlocks","BlockModel","_transactions","_previousHash","_proofOfWork","_hash","transactionsAsString","createHash","update","digest","BlockchainModel","_blockSubject","_blocks","_openTransactions","genesis","push","BehaviorSubject","asObservable","newBlock","top","next","length","MinerModel","_blockchain","_proofOfWorkSubject","Subject","_subscriptions","_top","interval","MINING_TIMEOUT","pipe","delayWhen","timer","mine","startsWith","addBlock","App","Boolean","window","location","hostname","match","ReactDOM","render","document","getElementById","navigator","serviceWorker","ready","then","registration","unregister"],"mappings":"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","file":"static/js/main.54ec9376.chunk.js","sourcesContent":["import React, { useEffect, useState } from 'react';\nimport MinerModel from './model/miner-model';\nimport { Subscription } from 'rxjs';\n\ninterface MinerProps {\n    miner: MinerModel;\n}\n\nconst Miner: React.FC<MinerProps> = (props: MinerProps) => {\n    const [proofOfWork, setProofOfWork] = useState('');\n    useEffect(() => {\n        const subscription: Subscription = props.miner.observeProofOfWorkSearch().subscribe((current: string) => setProofOfWork(current));\n        return () => subscription.unsubscribe();\n    });\n\n    return (\n        <span>\n            I am mining! {proofOfWork}\n        </span>\n    );\n};\n\nexport default Miner;\n","import React from 'react';\nimport TransactionModel from './model/transaction-model';\n\ninterface TransactionProps {\n    transaction: TransactionModel;\n}\n\nconst OpenTransaction: React.FC<TransactionProps> = (props: TransactionProps) => {\n    return(\n        <div>\n            Transfer {props.transaction.amount} from {props.transaction.from} to {props.transaction.to}.\n        </div>\n    );\n}\n\nexport default OpenTransaction;\n","export default class TransactionModel {\n\n    public get from(): string {\n        return this._from;\n    }\n\n    public get to(): string {\n        return this._to;\n    }\n\n    public get amount(): number {\n        return this._amount;\n    }\n\n    constructor(private _from: string,\n                private _to: string,\n                private _amount: number) {}\n\n}\n","import React, { useState, ChangeEvent, useEffect } from 'react';\nimport OpenTransaction from './OpenTransaction';\nimport BlockchainModel from './model/blockchain-model';\nimport TransactionModel from './model/transaction-model';\nimport { Subscription } from 'rxjs';\n\ninterface TransactionFormProps {\n    blockchain: BlockchainModel\n}\n\nconst TransactionForm: React.FC<TransactionFormProps> = (props: TransactionFormProps) => {\n    const [from, setFrom] = useState('');\n    const [to, setTo] = useState('');\n    const [amount, setAmount] = useState(1);\n    const [openTransactions, setOpenTransactions] = useState([]);\n\n    const onAmountChange = (event: ChangeEvent<HTMLInputElement>) => {\n        const value: number = parseInt(event.target.value);\n        if (value) {\n            setAmount(value);\n        } else {\n            setAmount(1);\n        }\n    }\n\n    const addTransaction = () => {\n        const newTransaction = new TransactionModel(from, to, amount);\n        props.blockchain.addOpenTransaction(newTransaction);\n        setOpenTransactions(t => [...t, newTransaction]);\n    };\n\n    useEffect(() => {\n        const subscription: Subscription = props.blockchain.observeNewBlock().subscribe(() => setOpenTransactions([]));\n        return () => subscription.unsubscribe();\n    }, [props.blockchain]);\n\n    const transactions = openTransactions\n        .map((transaction: TransactionModel, index: number) => <OpenTransaction key={index} transaction={transaction} />);\n\n    return (\n        <div>\n            <div>\n                <h2>New transaction</h2>\n                Transfer <input data-testid=\"amount\" className=\"input\" type=\"text\" value={amount} onChange={onAmountChange} /> \n                from <input data-testid=\"from\" className=\"input\" type=\"text\" value={from} onChange={event => setFrom(event.target.value)} /> \n                to <input data-testid=\"to\" className=\"input\" type=\"text\" value={to} onChange={event => setTo(event.target.value)} />\n                <button data-testid=\"add\" className=\"button is-link\" onClick={addTransaction}>Add</button>\n            </div>\n            {transactions}\n        </div>\n    );\n};\n\nexport default TransactionForm","import React from 'react';\nimport './Block.css';\nimport BlockModel from './model/block-model';\nimport TransactionModel from './model/transaction-model';\n\n\ninterface BlockProps {\n    block: BlockModel;\n}\n\nconst Block: React.FC<BlockProps> = (props: BlockProps) => {\n    const transactions = props.block.transactions\n        .map((transaction: TransactionModel) => `${transaction.amount} from ${transaction.from} to ${transaction.to}`)\n        .join(', ');\n    return (\n        <div className=\"block box\">\n            Transactions: {transactions}<br />\n            Previous hash: {props.block.previousHash}<br />\n            Hash: {props.block.hash}<br />\n            Proof of work: {props.block.proofOfWork}\n        </div>\n    );\n};\n\nexport default Block;","import React, { useEffect, useState } from 'react';\nimport Block from './Block';\nimport BlockchainModel from './model/blockchain-model';\nimport BlockModel from './model/block-model';\nimport { Subscription } from 'rxjs';\nimport './Blockchain.css';\n\ninterface BlockchainProps {\n    blockchain: BlockchainModel;\n}\n\nconst Blockchain: React.FC<BlockchainProps> = (props: BlockchainProps) => {\n\n    const [blocks, setBlocks] = useState(props.blockchain.blocks\n        .map((block: BlockModel, index: number) => <Block key={index} block={block} />)\n        .reverse());\n\n    useEffect(() => {\n        const subscription: Subscription = props.blockchain.observeNewBlock().subscribe(() => {\n            setBlocks(props.blockchain.blocks\n                .map((block: BlockModel, index: number) => <Block key={index} block={block} />)\n                .reverse());\n        });\n        return () => subscription.unsubscribe();\n    }, [props.blockchain]);\n\n    \n    return (\n        <div className=\"blockchain\">\n            {blocks}\n        </div>\n    );\n};\n\nexport default Blockchain;","import TransactionModel from \"./transaction-model\";\nimport { createHash } from \"crypto\";\n\nexport default class BlockModel {\n\n    private _hash: string;\n\n    constructor(private _transactions: Array<TransactionModel>,\n                private _previousHash: string,\n                private _proofOfWork: number) {\n\n        const transactionsAsString: string = _transactions\n            .map((transaction: TransactionModel) => `${transaction.from}${transaction.to}${transaction.amount}`)\n            .join();\n\n        this._hash = createHash('sha256')\n            .update(transactionsAsString)\n            .update(`${_previousHash}`)\n            .update(`${_proofOfWork}`)\n            .digest('hex');\n    }\n\n\n    \n    public get transactions(): Array<TransactionModel> {\n        return this._transactions;\n    }\n\n    public get previousHash(): string {\n        return this._previousHash;\n    }\n\n    public get hash(): string {\n        return this._hash;\n    }\n\n    public get proofOfWork(): number {\n        return this._proofOfWork;\n    }\n}\n","import { Subject, BehaviorSubject, Observable } from 'rxjs';\nimport BlockModel from './block-model';\nimport TransactionModel from './transaction-model';\n\nexport default class BlockchainModel {\n\n    private _blockSubject: Subject<BlockModel>;\n    private _blocks: Array<BlockModel> = [];\n    private _openTransactions: Array<TransactionModel> = [];\n\n    constructor() {\n        const genesis: BlockModel = new BlockModel([], '', 123);\n        this._blocks.push(genesis);\n        this._blockSubject = new BehaviorSubject(genesis);\n    }\n\n    public observeNewBlock(): Observable<BlockModel> {\n        return this._blockSubject.asObservable();\n    }\n\n    public get top(): BlockModel {\n        return this._blocks[this._blocks.length - 1];\n    }\n\n    public get blocks(): Array<BlockModel> {\n        return this._blocks;\n    }\n\n    public get openTransactions(): Array<TransactionModel> {\n        return this._openTransactions;\n    }\n\n    public addOpenTransaction(transaction: TransactionModel): void {\n        this._openTransactions.push(transaction);\n    }\n\n    public addBlock(proofOfWork: number): void {\n        const newBlock = new BlockModel(this._openTransactions, this.top.hash, proofOfWork);\n        // TODO: check the blockchain\n        this._blocks.push(newBlock);\n        this._openTransactions = [];\n        this._blockSubject.next(newBlock);\n    }\n}","import BlockchainModel from \"./blockchain-model\";\nimport { createHash } from \"crypto\";\nimport BlockModel from './block-model';\nimport { Subscription, interval, timer, Subject, Observable } from \"rxjs\";\nimport { delayWhen } from 'rxjs/operators';\n\nexport default class MinerModel {\n\n    private static readonly MINING_TIMEOUT = 50;\n\n    private _proofOfWorkSubject: Subject<string> = new Subject();\n    private _subscriptions: Array<Subscription> = [];\n    private _top: BlockModel;\n    private _proofOfWork = 0;\n\n    constructor(private  _blockchain: BlockchainModel) {\n        this._subscriptions.push(_blockchain.observeNewBlock()\n            .subscribe((block: BlockModel) => {\n                this._top = block;\n                this._proofOfWork = 0;\n            }));\n\n        this._subscriptions.push(interval(MinerModel.MINING_TIMEOUT)\n            .pipe(\n                delayWhen(() => {\n                    if (this._proofOfWork === 0) {\n                        return timer(3000);\n                    } else {\n                        return timer(0);\n                    }\n                })\n            )\n            .subscribe(() => this.mine()));\n    }\n\n    public observeProofOfWorkSearch(): Observable<string> {\n        return this._proofOfWorkSubject.asObservable();\n    }\n\n    private mine(): void {\n        this._proofOfWorkSubject.next(`Currently checking ${this._proofOfWork}`);\n\n        const aHash: string = createHash('sha256')\n            .update(`${this._top.proofOfWork}${this._proofOfWork}${this._top.hash}`)\n            .digest('hex');\n        if (aHash.startsWith('00')) {\n            this._proofOfWorkSubject.next(`Wohoo! ${this._proofOfWork} worked. I am creating a new block.`);\n            this._blockchain.addBlock(this._proofOfWork);\n        } else {\n            ++this._proofOfWork;\n        }\n    }\n\n}","import React from 'react';\nimport './App.css';\nimport Miner from './Miner';\nimport TransactionForm from './TransactionForm';\nimport Blockchain from './Blockchain';\nimport BlockchainModel from './model/blockchain-model';\nimport MinerModel from './model/miner-model';\n\nconst App: React.FC = () => {\n    \n    const blockchain: BlockchainModel = new BlockchainModel();\n    const miner: MinerModel = new MinerModel(blockchain);    \n    \n    return (\n        <div className=\"tile is-ancestor\">\n            <div className=\"tile is-vertical\">\n                <div className=\"tile is-parent\">\n                    <div className=\"tile is-child box\">\n                        <TransactionForm blockchain={blockchain} />\n                    </div>\n                    <div className=\"tile is-child box\">\n                        <Miner miner={miner} />\n                    </div>\n                </div>\n                <div className=\"tile is-parent\">\n                    <div className=\"tile is-child box\">\n                        Participants\n                    </div>\n                    <div className=\"tile is-child box\">\n                        <Blockchain blockchain={blockchain} />\n                    </div>\n                </div>\n            </div>\n        </div>\n    );\n}\n\nexport default App;\n","// This optional code is used to register a service worker.\n// register() is not called by default.\n\n// This lets the app load faster on subsequent visits in production, and gives\n// it offline capabilities. However, it also means that developers (and users)\n// will only see deployed updates on subsequent visits to a page, after all the\n// existing tabs open on the page have been closed, since previously cached\n// resources are updated in the background.\n\n// To learn more about the benefits of this model and instructions on how to\n// opt-in, read https://bit.ly/CRA-PWA\n\nconst isLocalhost = Boolean(\n  window.location.hostname === 'localhost' ||\n    // [::1] is the IPv6 localhost address.\n    window.location.hostname === '[::1]' ||\n    // 127.0.0.0/8 are considered localhost for IPv4.\n    window.location.hostname.match(\n      /^127(?:\\.(?:25[0-5]|2[0-4][0-9]|[01]?[0-9][0-9]?)){3}$/\n    )\n);\n\ntype Config = {\n  onSuccess?: (registration: ServiceWorkerRegistration) => void;\n  onUpdate?: (registration: ServiceWorkerRegistration) => void;\n};\n\nexport function register(config?: Config) {\n  if (process.env.NODE_ENV === 'production' && 'serviceWorker' in navigator) {\n    // The URL constructor is available in all browsers that support SW.\n    const publicUrl = new URL(\n      process.env.PUBLIC_URL,\n      window.location.href\n    );\n    if (publicUrl.origin !== window.location.origin) {\n      // Our service worker won't work if PUBLIC_URL is on a different origin\n      // from what our page is served on. This might happen if a CDN is used to\n      // serve assets; see https://github.com/facebook/create-react-app/issues/2374\n      return;\n    }\n\n    window.addEventListener('load', () => {\n      const swUrl = `${process.env.PUBLIC_URL}/service-worker.js`;\n\n      if (isLocalhost) {\n        // This is running on localhost. Let's check if a service worker still exists or not.\n        checkValidServiceWorker(swUrl, config);\n\n        // Add some additional logging to localhost, pointing developers to the\n        // service worker/PWA documentation.\n        navigator.serviceWorker.ready.then(() => {\n          console.log(\n            'This web app is being served cache-first by a service ' +\n              'worker. To learn more, visit https://bit.ly/CRA-PWA'\n          );\n        });\n      } else {\n        // Is not localhost. Just register service worker\n        registerValidSW(swUrl, config);\n      }\n    });\n  }\n}\n\nfunction registerValidSW(swUrl: string, config?: Config) {\n  navigator.serviceWorker\n    .register(swUrl)\n    .then(registration => {\n      registration.onupdatefound = () => {\n        const installingWorker = registration.installing;\n        if (installingWorker == null) {\n          return;\n        }\n        installingWorker.onstatechange = () => {\n          if (installingWorker.state === 'installed') {\n            if (navigator.serviceWorker.controller) {\n              // At this point, the updated precached content has been fetched,\n              // but the previous service worker will still serve the older\n              // content until all client tabs are closed.\n              console.log(\n                'New content is available and will be used when all ' +\n                  'tabs for this page are closed. See https://bit.ly/CRA-PWA.'\n              );\n\n              // Execute callback\n              if (config && config.onUpdate) {\n                config.onUpdate(registration);\n              }\n            } else {\n              // At this point, everything has been precached.\n              // It's the perfect time to display a\n              // \"Content is cached for offline use.\" message.\n              console.log('Content is cached for offline use.');\n\n              // Execute callback\n              if (config && config.onSuccess) {\n                config.onSuccess(registration);\n              }\n            }\n          }\n        };\n      };\n    })\n    .catch(error => {\n      console.error('Error during service worker registration:', error);\n    });\n}\n\nfunction checkValidServiceWorker(swUrl: string, config?: Config) {\n  // Check if the service worker can be found. If it can't reload the page.\n  fetch(swUrl, {\n    headers: { 'Service-Worker': 'script' }\n  })\n    .then(response => {\n      // Ensure service worker exists, and that we really are getting a JS file.\n      const contentType = response.headers.get('content-type');\n      if (\n        response.status === 404 ||\n        (contentType != null && contentType.indexOf('javascript') === -1)\n      ) {\n        // No service worker found. Probably a different app. Reload the page.\n        navigator.serviceWorker.ready.then(registration => {\n          registration.unregister().then(() => {\n            window.location.reload();\n          });\n        });\n      } else {\n        // Service worker found. Proceed as normal.\n        registerValidSW(swUrl, config);\n      }\n    })\n    .catch(() => {\n      console.log(\n        'No internet connection found. App is running in offline mode.'\n      );\n    });\n}\n\nexport function unregister() {\n  if ('serviceWorker' in navigator) {\n    navigator.serviceWorker.ready.then(registration => {\n      registration.unregister();\n    });\n  }\n}\n","import React from 'react';\nimport ReactDOM from 'react-dom';\nimport './index.css';\nimport App from './App';\nimport * as serviceWorker from './serviceWorker';\n\nReactDOM.render(<App />, document.getElementById('root'));\n\n// If you want your app to work offline and load faster, you can change\n// unregister() to register() below. Note this comes with some pitfalls.\n// Learn more about service workers: https://bit.ly/CRA-PWA\nserviceWorker.unregister();\n"],"sourceRoot":""}